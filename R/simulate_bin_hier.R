#' Simulate Hierarchical Data with a Binary Response
#'
#' @description
#' Simulates hierarchical binary data where observations are grouped into clusters,
#' with an ordered covariate (X1) and an unordered covariate (X2), and random effects
#' at the cluster level.
#'
#' @param length_X1 Integer. Number of levels for the ordered factor X1 (must be >= 2).
#' @param length_X2 Integer. Number of levels for the unordered factor X2 (must be between 2 and 26).
#' @param formula_X1 Character. Formula specifying how X1 depends on X2.
#' @param formula_Y Character. Formula specifying how Y depends on X1 and X2.
#' @param para_X1 Matrix. Coefficient matrix for modeling X1 given X2.
#' Must have \code{length_X1} rows and \code{(length_X2 - 1)} columns.
#' @param beta Numeric vector. Coefficients for modeling the binary outcome Y.
#' Must match the number of columns of the model matrix generated by \code{formula_Y}.
#' @param n_clus Integer. Number of clusters (e.g., groups, hospitals).
#' @param n_obs Integer. Number of observations per cluster.
#' @param sd_U Numeric. Standard deviation of the random effects at the cluster level.
#' @param seed Integer or NULL. Random seed for reproducibility (default is NULL).
#'
#' @return A `data.frame` with the following columns:
#' \describe{
#'   \item{id}{Integer identifier for each observation}
#'   \item{Y}{Binary outcome (factor: 0 or 1)}
#'   \item{X1}{Ordered factor with \code{length_X1} levels}
#'   \item{X2}{Unordered factor with \code{length_X2} alphabetic levels (a, b, c, ...)}
#'   \item{clus}{Cluster identifier (factor)}
#' }
#'
#' @examples
#' dat2 <- simulate_bin_hier(
#'   length_X1 = 3,
#'   length_X2 = 4,
#'   formula_X1 = "~ X2",
#'   formula_Y = "~ X1 + X2",
#'   para_X1 = matrix(c(rep(2,3), rep(1,3), rep(2.5,3)), ncol = 3),
#'   beta = c(-1, 1, -2, 2, 1, 2),
#'   n_clus = 10,
#'   n_obs = 200,
#'   sd_U = 0.45,
#'   seed = 123
#' )
#' head(dat2)
#' @importFrom stats as.formula model.matrix rnorm
#' @export
simulate_bin_hier <- function(length_X1, length_X2, formula_X1, formula_Y,
                              para_X1, beta, n_clus, n_obs, sd_U, seed = NULL) {

  if (!is.null(seed)) set.seed(seed)

  # Vérifications des entrées
  if (!is.numeric(length_X1) || length_X1 < 2) {
    stop("length_X1 must be an integer greater than or equal to 2.")
  }
  if (!is.numeric(length_X2) || length_X2 < 2 || length_X2 > 26) {
    stop("length_X2 must be an integer between 2 and 26.")
  }
  if (!is.matrix(para_X1) || nrow(para_X1) != (length_X2 - 1) || ncol(para_X1) != length_X1) {
    stop(paste0(
      "para_X1 must be a matrix with ", (length_X2 - 1), " rows and ", length_X1, " columns."
    ))
  }
  if (!is.numeric(beta)) {
    stop("beta must be a numeric vector.")
  }
  if (!is.numeric(n_clus) || n_clus <= 0) {
    stop("n_clus must be a positive integer.")
  }
  if (!is.numeric(n_obs) || n_obs <= 0) {
    stop("n_obs must be a positive integer.")
  }
  if (!is.numeric(sd_U) || sd_U < 0) {
    stop("sd_U must be a non-negative number.")
  }

  n_total <- n_clus * n_obs

  # Génération des groupes
  clus <- factor(rep(seq_len(n_clus), each = n_obs))

  # Génération de X2
  levels_X2 <- 1:length_X2
  X2 <- factor(
    sample(levels_X2, size = n_total, replace = TRUE),
    levels = levels_X2
  )

  # Génération de X1
  model_X1 <- model.matrix(as.formula(formula_X1), data = data.frame(X2 = X2))[, -1, drop = FALSE]
  eta_X1 <- model_X1 %*% para_X1
  prob_X1 <- t(apply(eta_X1, 1, function(x) {
    ex <- exp(x - max(x))
    ex / sum(ex)
  }))

  X1_num <- apply(prob_X1, 1, function(p) sample(seq_len(length_X1), size = 1, prob = p))
  X1 <- factor(X1_num, levels = seq_len(length_X1), ordered = TRUE)

  # Génération des effets aléatoires par cluster
  U <- rnorm(n_clus, mean = 0, sd = sd_U)
  ZU <- U[clus]

  # Génération de Y
  model_Y <- model.matrix(as.formula(formula_Y), data = data.frame(X1 = X1, X2 = X2))

  if (length(beta) != ncol(model_Y)) {
    stop(paste0(
      "The number of elements in beta (", length(beta),
      ") does not match the number of columns in the model matrix for Y (", ncol(model_Y), ")."
    ))
  }

  eta_Y <- as.vector(model_Y %*% beta) + ZU
  prob_Y <- stats::plogis(eta_Y)
  Y <- factor(stats::rbinom(n_total, size = 1, prob = prob_Y), levels = 0:1)

  # Assemble the final dataset
  data.frame(
    id = seq_len(n_total),
    Y = Y,
    X1 = X1,
    X2 = X2,
    clus = clus,
    stringsAsFactors = FALSE
  )
}
